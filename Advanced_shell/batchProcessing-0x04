#!/bin/bash

# Task 5: Parallel Data Fetching
# Objective: Speed up data retrieval using parallel processing

# Configuration
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
OUTPUT_DIR="pokemon_data"
ERROR_FILE="errors.txt"
API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
MAX_RETRIES=3
RETRY_DELAY=2
TIMEOUT=60  # Maximum time to wait for all processes

# Array to store background process IDs
declare -a PIDS=()

# Function to log errors
log_error() {
    local error_message="$1"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: ${error_message}" >> "${ERROR_FILE}"
}

# Function to create output directory
setup_directory() {
    if [ ! -d "${OUTPUT_DIR}" ]; then
        mkdir -p "${OUTPUT_DIR}"
        if [ $? -ne 0 ]; then
            log_error "Failed to create directory ${OUTPUT_DIR}"
            echo "ERROR: Could not create output directory"
            exit 1
        fi
    fi
}

# Function to cleanup background processes on exit or interrupt
cleanup_processes() {
    echo ""
    echo "Cleaning up background processes..."
    
    # Check if there are any running jobs
    if jobs -p > /dev/null 2>&1; then
        # Kill all background jobs
        jobs -p | xargs -r kill 2>/dev/null
        
        # Wait a moment for processes to terminate
        sleep 1
        
        # Force kill any remaining processes
        jobs -p | xargs -r kill -9 2>/dev/null
    fi
    
    echo "Cleanup completed."
}

# Set up trap to cleanup on script exit or interrupt
trap cleanup_processes EXIT INT TERM

# Function to fetch data for a single Pokemon with retry logic
fetch_pokemon_with_retry() {
    local pokemon_name="$1"
    local api_url="${API_BASE_URL}/${pokemon_name}"
    local output_file="${OUTPUT_DIR}/${pokemon_name}.json"
    local attempt=1
    
    echo "Fetching data for ${pokemon_name}..."
    
    # Retry loop
    while [ ${attempt} -le ${MAX_RETRIES} ]; do
        # Make the API request with curl
        http_code=$(curl -s -S -w "%{http_code}" -o "${output_file}" \
                    --connect-timeout 10 --max-time 30 "${api_url}" 2>&1)
        
        # Check curl exit status
        curl_exit_code=$?
        
        # If curl command succeeded
        if [ ${curl_exit_code} -eq 0 ]; then
            # Extract HTTP status code (last 3 characters)
            http_status="${http_code: -3}"
            
            # Check if HTTP status code is 200 (OK)
            if [ "${http_status}" = "200" ]; then
                # Verify the output file exists and is not empty
                if [ -s "${output_file}" ]; then
                    # Verify it's valid JSON
                    if jq empty "${output_file}" 2>/dev/null; then
                        echo "Saved data to ${output_file} ✅"
                        return 0
                    else
                        log_error "Invalid JSON for ${pokemon_name} on attempt ${attempt}"
                    fi
                else
                    log_error "Empty response for ${pokemon_name} on attempt ${attempt}"
                fi
            elif [ "${http_status}" = "404" ]; then
                # 404 means invalid Pokemon name - don't retry
                log_error "Invalid Pokemon name: ${pokemon_name} (HTTP 404)"
                echo "Failed to fetch ${pokemon_name} - Invalid name ❌"
                [ -f "${output_file}" ] && rm "${output_file}"
                return 1
            else
                log_error "HTTP ${http_status} for ${pokemon_name} on attempt ${attempt}"
            fi
        else
            # Network error or curl failure
            log_error "Network error for ${pokemon_name} on attempt ${attempt} (curl exit code: ${curl_exit_code})"
        fi
        
        # If we reach here, the request failed
        if [ ${attempt} -lt ${MAX_RETRIES} ]; then
            echo "Attempt ${attempt}/${MAX_RETRIES} failed for ${pokemon_name}. Retrying in ${RETRY_DELAY} seconds..."
            sleep ${RETRY_DELAY}
        else
            # Final attempt failed
            log_error "Failed to fetch ${pokemon_name} after ${MAX_RETRIES} attempts"
            echo "Failed to fetch ${pokemon_name} after ${MAX_RETRIES} attempts ❌"
            [ -f "${output_file}" ] && rm "${output_file}"
            return 1
        fi
        
        attempt=$((attempt + 1))
    done
    
    return 1
}

# Function to monitor and display running jobs
monitor_jobs() {
    local job_count=$(jobs -r | wc -l)
    if [ ${job_count} -gt 0 ]; then
        echo "Running background jobs: ${job_count}"
        jobs -l
    fi
}

# Function to process all Pokemon in parallel
process_all_pokemon_parallel() {
    echo "Starting parallel fetch for ${#POKEMON_LIST[@]} Pokémon..."
    echo ""
    
    # Record start time
    start_time=$(date +%s)
    
    # Launch all fetch operations in background
    for pokemon in "${POKEMON_LIST[@]}"; do
        fetch_pokemon_with_retry "${pokemon}" &
        # Store the PID of the background process
        PIDS+=($!)
    done
    
    echo ""
    echo "All fetch processes launched in parallel."
    echo ""
    
    # Display running jobs
    echo "Checking background jobs..."
    jobs -l
    echo ""
    
    echo "Waiting for all processes to complete..."
    echo ""
    
    # Wait for all background processes to complete
    local success_count=0
    local fail_count=0
    local wait_start=$(date +%s)
    
    for pid in "${PIDS[@]}"; do
        # Check if process is still running
        if kill -0 ${pid} 2>/dev/null; then
            # Wait for specific process with timeout check
            wait ${pid} 2>/dev/null
            exit_status=$?
        else
            # Process already finished
            wait ${pid} 2>/dev/null
            exit_status=$?
        fi
        
        if [ ${exit_status} -eq 0 ]; then
            ((success_count++))
        else
            ((fail_count++))
        fi
        
        # Check for timeout
        local current_time=$(date +%s)
        local elapsed=$((current_time - wait_start))
        if [ ${elapsed} -gt ${TIMEOUT} ]; then
            echo "WARNING: Timeout reached. Killing remaining processes..."
            # Kill any remaining background jobs
            jobs -p | xargs -r kill 2>/dev/null
            break
        fi
    done
    
    # Verify no jobs are still running
    if jobs -r > /dev/null 2>&1; then
        echo "WARNING: Some jobs still running. Cleaning up..."
        jobs -p | xargs -r kill 2>/dev/null
    fi
    
    # Record end time
    end_time=$(date +%s)
    
    # Calculate duration
    duration=$((end_time - start_time))
    
    # Display summary
    echo ""
    echo "========================================="
    echo "All processes completed!"
    echo "Time taken: ${duration} seconds"
    echo "Success: ${success_count} | Failed: ${fail_count}"
    echo "========================================="
    
    # Show error log location if there were failures
    if [ ${fail_count} -gt 0 ]; then
        echo "Check ${ERROR_FILE} for error details"
    fi
}

# Main execution
main() {
    # Setup output directory
    setup_directory
    
    # Process all Pokemon in parallel
    process_all_pokemon_parallel
    
    exit 0
}

# Run the main function
main